//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34014
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using UnityEngine;
namespace QuickMesh
{
		public class Selection
		{
		private List<Face> Faces = new List<Face>();
		public List<Face> Selected = new List<Face>();
		public Dictionary<String, Dictionary<Face,String>> Attributes = new Dictionary<String, Dictionary<Face,String>>();

				public Selection ()
				{
				}

		public Selection Make(){
			Selection s = new Selection ();
			s.Faces = this.Faces;
			s.Attributes = this.Attributes;
			return s;
		}

		public Selection Circle(int vertexCount){
			Selection s = Make ();
			float arcLength = Mathf.PI * 2 / vertexCount;
			Face face = new Face();
			for (int i = 0; i < vertexCount; i++){
				Vertex vertex = new Vertex(Mathf.Cos(-i*arcLength), Mathf.Sin(-i*arcLength), 0);
				face.Vertices.Add(vertex);
			}
			Faces.Add(face);
			s.Selected.Add (face);
			return s;
		}

		public delegate void Mapper(Selection selection, Face face);

		public String Attr(Face face, String key){
			if (!Attributes.ContainsKey (key)) {
				return null;
			}
			var dict = Attributes [key];
			if (!dict.ContainsKey (face)) {
				return null;
			}
			return dict [face];
		}

		public void Attr(Face face, String key, String val){

			if (!Attributes.ContainsKey(key))
			{
				Attributes[key]= new Dictionary<Face, string> ();
			}
			Attributes[key] [face] = val;
		}

		public Selection Extrude(float distance){
			return Each ((s,f) => {
				Attr (f,"hidden","true");
				Vector3 extrusion = f.Normal()*distance;

				Face cap = new Face();
				Attr (cap, "cap","true");
				cap.Orientation = f.Orientation;
				int vertexCount = f.Vertices.Count;

				for(int i=0;i<vertexCount;i++){
					cap.Vertices.Add (new Vertex(f.Vertices[i].Position+extrusion));
				}

				for(int i=0;i<vertexCount;i++){
					Face side = new Face();
					Attr (side,"side",i.ToString());

					side.Vertices.Add (f.Vertices[(i+1)%vertexCount]);
					side.Vertices.Add (cap.Vertices[(i+1)%vertexCount]);
					side.Vertices.Add (cap.Vertices[i]);
					side.Vertices.Add (f.Vertices[i]);


					side.Orientation = Vector3.Cross(side.Normal(), extrusion).normalized;

					s.AddSelected (side);
				}

				s.AddSelected(cap);
			});
		}

		public void AddSelected(Face face){
			Faces.Add (face);
			Selected.Add (face);
		}

		public Selection Each(Mapper m){
			Selection s = Make ();
			foreach (Face face in Selected) {
				m(s,face);
			}
			return s;
		}

		public Mesh Finish(){
			Mesh m = new Mesh ();
			List<int> triangles = new List<int> ();
			List<Vector3> vertices = new List<Vector3> ();

			foreach (Face face in Faces) {
				Debug.Log (Attr (face,"hidden"));
				if(Attr (face,"hidden")!="true"){
				int first = vertices.Count;
				for (int i=0; i<face.Vertices.Count;i++){
					vertices.Add(face.Vertices[i].Position);
				}
				for (int i=0; i<face.Vertices.Count-2; i++) {
					
					triangles.Add(first);
					triangles.Add(first+i+1);
					triangles.Add(first+i+2);
				}
				}
			}
			m.vertices = vertices.ToArray();
			m.triangles = triangles.ToArray ();	
			m.RecalculateNormals();
			return m;
		}
	}
}

